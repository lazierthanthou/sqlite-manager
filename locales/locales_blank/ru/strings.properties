# Description Localization

extensions.{SQLiteManager@mrinalkant.blogspot.com}.description=Менеджер баз данных SQLite для Mozilla Firefox.
dbDoesNotExist=Этот файл не существует: %1$S
lastDbDoesNotExist=Файл больше не существует: %1$S
promptLastDbTitle=Открыть с последней базой данных?
promptLastDbAsk=Вы хотите открыть последнюю использовавшуюся базу данных:
promptLastDbOpen=Больше не спрашивать, а просто открывать последнюю использовавшуюся базу данных.
dropColumn=Удалить столбец
alterColumn=Изменить столбец
allowed=Разрешено
notAllowed=Не разрешено
noRecord=Запись не выбрана
firstOpenADb=Сначала вы должны открыть базу данных.
writeSomeSql=Запишите какие-нибудь SQL-операторы, а затем выполните их.
importData=Импорт данных
noDbOrTable=База данных и/или таблица не выбраны.
noDb=База данных не выбрана
onlyOneRecord=Выберите одну и только одну запись для редактирования.
selectProfileDb=(Выберите базу данных профиля)
selectDbInDefaultDir=(Выберите БД в каталоге по умолчанию)
invalidProfileDb=Неправильный выбор. Выберите файл из выпадающего меню.
extName=Менеджер SQLite
sqlite=SQLite
filesInProfileDbList=Количество файлов в выбранном каталоге
dropDone=Успешно удалено
noObjectToDelete=Удаление не удалось, поскольку нет объектов типа
selectDb=Выберите базу данных SQLite
ok=УСПЕШНО
notOk=НЕ УСПЕШНО. Чтобы увидеть ошибки, выполните оператор "%1$S" во вкладке «Выполнить запрос».
sqliteDbFiles=Файлы БД SQLite
copyFailed=Копирование не удалось. Хотите создать новую базу данных?
noOpenDb=Не найдено ни одно открытой базы данных
loadDataFailed=Загрузка данных не удалась.
rowsReturned=Возвращённое число строк: %1$S
selectFolderForDb=Выберите папку для сохранения файла БД
dbFileExists=Файл уже существует. Открываю существующую базу данных
confirmClose=Вы уверены, что хотите закрыть открытую в настоящий момент базу данных?
confirmBackup=Вы хотите сделать резервную копию этого файла базы данных перед тем как открыть его?
integrityResultPrefix=Проверка целостности базы данных с помощью "%1$S".\nРезультат
pragma.changed=PRAGMA %1$S: Значение изменилось на %2$S.
confirm.changeSchemaVersion=Обычно версия схемы изменяется только изнутри SQLite. Она увеличивается SQLite всякий раз при изменении схемы базы данных (путём создания или удаления таблицы или индекса). Версия схемы используется SQLite каждый раз при выполнении запроса, чтобы гарантировать, что внутренний кэш схемы, используемый при компиляции SQL-запроса, соответствует схеме базы данных для которой фактически выполняется компилируемый запрос. Нарушение этого механизма путём использования для изменения версии схемы оператора «PRAGMA версия_схемы» — потенциально опасно и может привести к сбоям в программе или повреждению базы данных. Используйте с осторожностью!
dangerous.op=Опасная операция
q.proceed=Вы всё ещё хотите продолжить?
vacuum.title=Результат сжатия
vacuum.details=База данных была сжата оператором VACUUM.\nДо сжатия:\n\tКоличество страниц = %1$S\n\tРазмер базы = %2$S байт(а,ов)\nПосле сжатия:\n\tКоличество страниц = %3$S\n\tРазмер базы = %4$S байт(а,ов)
# createManager.js

createMngr.index.title=Создать индекс таблицы %1$S
createMngr.index.donotuse=не использовать
createMngr.index.ascending=по возрастанию
createMngr.index.descending=по убыванию
createMngr.index.cannotBeNull=Имя не может быть пустым
createMngr.index.noFieldsSelected=Нет выбранных полей
createMngr.index.confirm=Создать индекс %1$S
createMngr.dropColumn=Удалить столбец %1$S из %2$S
createMngr.alterColumn=Изменить столбец %1$S в таблице %2$S
createMngr.tbl.cannotBeNull=Имя таблицы не может быть пустым
createMngr.tbl.cannotBeginSqlite=Имя таблицы не может начинаться с «sqlite_»
createMngr.invalidColname=Имя столбца не должно совпадать с «rowid», «_rowid» или «oid»
createMngr.autoincError.cols=Использование AUTOINCREMENT для более чем одного столбца — ошибка.
createMngr.autoincError.PK=Использование AUTOINCREMENT не разрешено, если первичный ключ состоит из двух и более столбцов.
createMngr.modifyView=Изменить производную таблицу
createMngr.view.cannotBeNull=Имя не может быть пустым
createMngr.statement.cannotBeNull=Оператор не может отсутствовать
createMngr.trigger.cannotBeNull=Имя не может быть пустым
createMngr.trigger.cannotBeEmpty=Этапы триггера не могут быть пустыми
createMngr.trigger.confirm=Создать триггер %1$S
# exim.js

eximTab.import.label=Мастер импорта
eximTab.export.label=Мастер экспорта
eximTab.export.subtitle=Экспортирование %1$S:
eximLblObjectType=Имя
eximTab.export.label02=Мастер экспорта: Экспортирование %1$S:
exim.exportToFile=Экспорт в файл
exim.chooseFileExport=Выберите файл для сохранения экспортируемых данных.
exim.exportNum=%1$S записи(ей) экспортировано в %2$S
exim.chooseFileImport=Выберите файл для импорта
exim.alertNull.title=SQLite Manager — Ошибка импорта
exim.alertNull.msg=Ошибка импорта: Нет файла для импортирования!\nВыберите файл, содержащий данные, которые вы хотите импортировать.
exim.importNum.title=Импорт:
exim.importNum.statements=Выполнен(ы) %1$S оператор(а,ов).
exim.importNum.records=Импортирована(ы) %1$S запись(и,ей).
exim.importFailed=Ошибка импорта: Не удалось импортировать.
exim.importCancelled=Импорт отменён.
exim.import.tablename=Введите имя таблицы в которую будут импортированы данные:
exim.import.invalidTablename=Ошибка импорта: Введите действительное имя таблицы.
exim.confirm.rows.title=SQLite Manager
exim.confirm.rows.msg=Вы уверены, что хотите выполнить следующую операцию(и):\nИмпорт данных: Строки =
exim.import.failed=Не удалось импортировать %1$S строк(и).\nКоличество строк:
exim.confirm.sqlStats.title=SQLite Manager
exim.confirm.sqlStats.msg=Вы уверены, что хотите выполнить следующую операцию(и):\nИмпорт данных путём выполнения SQL-операторов\nКоличество SQL-операторов:
exim.confirm.irows.title=SQLite Manager
exim.confirm.irows.msg=Вы уверены, что хотите выполнить следующую операцию(и):\nИмпорт данных: Строки =
exim.confirm.tabName.title=SQLite Manager
exim.confirm.tabName.msg=Вы уверены, что хотите импортировать данные в существующую таблицу %1$S?\nЩёлкните OK, чтобы продолжить импортирование.
exim.confirm.createTable.title=SQLite Manager
exim.confirm.createTable.msg=Будет создана новая таблица с именем %1$S. Вы хотите изменить эту таблицу?\nЩёлкните OK, чтобы изменить её.
# extManager.js

extManager.dropTableConfirm=Вы уверены, что хотите удалить таблицу %1$S?\nВы потеряете все данные, связанные с историей запросов во вкладке выполнения SQL.
extManager.deleteQueries=Удалить все сохранённые запросы из таблицы:
extManager.qName.enter=Введите имя запроса, который будет сохранён
extManager.qName.exists=Запрос, имеющий выбранное название, уже существует.
# globals.js

globals.confirm.msg=Вы уверены, что хотите выполнить следующую операцию(и):
globals.confirm.title=Подтвердите операцию
# RowOperations.js

rowOp.insert.title=Добавить новую запись
rowOp.insertSuccess.msg=Запись успешно вставлена. Теперь вы можете добавить другую запись. Нажмите «Отмена», чтобы выйти из этого диалога.
rowOp.insertFailure.msg=Вставка записи не удалась. Теперь вы можете добавить другую запись. Нажмите «Отмена», чтобы выйти из этого диалога.
rowOp.update.title=Править запись
rowOp.updateSuccess.msg=Запись успешно обновлена. Нажмите «Отмена», чтобы выйти из этого диалога.
rowOp.updateFailure.msg=Обновление записи не удалось. Нажмите «Отмена», чтобы выйти из этого диалога.
rowOp.delete.title=Удалить запись
rowOp.search.title=Поиск в таблице:
rowOp.searchView.title=Поиск в производной таблице:
rowOp.enterFieldValues=Введите значения полей
rowOp.saveBlob.fp.title=Сохранить BLOB в файл
rowOp.addBlob.fp.title=Выбрать BLOB файл
rowOp.addBlob.showBlobSize=(Размер:%1$S)
rowOp.tooltip.expandInput=Растянуть область ввода
rowOp.tooltip.collapseInput=Сжать область ввода
rowOp.tooltip.addBlob=Добавить файл как BLOB
rowOp.tooltip.saveBlob=Сохранить BLOB-данные как файл
rowOp.tooltip.deleteBlob=Удалить BLOB-данные из этого столбца
rowOp.viewName=Имя производной таблицы:
rowOp.noChanges=Нет изменённых полей. Вы можете использовать кнопку «Отмена», чтобы отменить операцию
rowOp.confirmation=Вы уверены, что хотите выполнить следующий оператор(ы):
# sqlite.js

sqlite.size=(Размер:%1$S)
sqlite.blobSize=BLOB (Размер:%1$S)
sqlite.confirm.deleteRecords=Удалить все записи
sqlite.confirm.renameTable=Переименовать таблицу %1$S
sqlite.confirm.analyzeTable=Анализировать таблицу
sqlite.confirm.addColumn=Добавить столбец к таблице %1$S
# sqlitemanager.js

sqlm.selectQuery=Выберите запрос
sqlm.noForeignKey=в этой таблице не определён ни один внешний ключ
sqlm.fKeyNoTable=Сбой: упоминаемая таблица %1$S не существует
sqlm.fKeySelfReference=Сбой: по крайней мере один внешний ключ ссылается непосредственно на эту таблицу
sqlm.fKeyUnnamedColumn=Сбой: столбец %1$S ссылается на неназванный столбец (могло произойти из-за неявной ссылки, которая не обработана)
sqlm.confirm.title=Подтвердите операцию
sqlm.confirm.msg=Вы хотите создать триггеры для внешнего ключа?\n\n
sqlm.nothingToSave=Нечего сохранять.
sqlm.enterDatabaseName=Введите имя базы данных (%1$S будет автоматически добавлено к имени)
sqlm.enterDatabaseName.title=Введите имя базы данных
sqlm.enterADSName=Введите имя ADS:
sqlm.enterADSName.descr=Введите имя ADS содержащего БД SQLite
sqlm.alert.fileNotFound=Файл не найден:
sqlm.confirm.createTable=Создать таблицу %1$S
sqlm.confirm.createObj=Создать %1$S %2$S
sqlm.confirm.modifyView=Изменить производную таблицу %1$S
sqlm.confirm.dangerousOp=Это — потенциально опасная операция. SQLite не поддерживает операторы, которые могут изменять столбцы в таблице. Здесь, мы пытаемся воссоздать заново SQL-оператор CREATE путём отыскания директивы table_info, которая не содержит полную информацию о структуре существующей таблицы.\n\n
sqlm.alterColumn.name=Определите новое имя столбца
# sqlm.alterColumn.type=Enter the new column type

sqlm.export.fp.title=Экспорт в файл
sqlm.export.fp.descr=Выберите файл для сохранения в него экспортируемых данных.
sqlm.export.db=База данных экспортирована в %1$S
sqlm.export.dbstructure=Структура базы данных экспортирована в %1$S
sqlm.export.tables=%1$S таблиц(ы) экспортированы в %2$S
sqlm.renameTable=Переименовать таблицу %1$S
sqlm.renameTable.descr=Введите новое имя таблицы
sqlm.renameTable.confirm=Переименовать таблицу %1$S
sqlm.renameObj=Переименовать %1$S %2$S
sqlm.renameObj.descr=Введите новое имя %1$S
sqlm.renameObj.newSqlFailed=Не удалось создать SQL-оператор
sqlm.renameObj.confirm=Переименовать %1$S %2$S
sqlm.copyTable.newSqlFailed=Не удалось создать SQL-оператор для копирования таблицы
sqlm.copyTable.confirm=Скопировать таблицу
sqlm.deleteRecs=Удалено %1$S записи(ей) из %2$S
sqlm.selectDefaultDir=Выберите каталог по умолчанию
sqlm.tooltip.profileDir=Каталог профиля
sqlm.detachDb.alert=Невозможно отсоединить этот элемент. Эта операция действительна только для присоединённой базы данных.
sqlm.detachDb.confirm=Вы уверены, что действительно хотите отсоединить базу данных %1$S?\nПуть присоединённой БД:
sqlm.detachDb.msgOk=База данных %1$S отсоединена.
sqlm.detachDb.msgFailed=Базу данных %1$S не удалось отсоединить.
sqlm.attachDb=Присоединить базу данных %1$S
sqlm.attachDb.descr=Введите имя базы данных
sqlm.attachDb.msgOk=База данных %1$S присоединена как %2$S
sqlm.attachDb.msgFailed=Базу данных %1$S не удалось присоединить.
sqlm.backup.failed=Не удалось создать файл резервной копии: %1$S\nСообщение об ошибке: %2$S
sqlm.tooltip.tempObj=Временные объекты
sqlm.tooltip.tempDbObj=Временные объекты БД
sqlm.tooltip.attachedDbs=--- Присоединённые базы данных ---
defaultval.title=Нет значения по умолчанию
defaultval.message=Нет никакого значения по умолчанию, связанного с этим столбцом
udf.newFunctionArgLength=Количество аргументов функции должно быть целым числом.\n-1 означает, что число аргументов не ограничено.
udf.newFunctionBody=Запишите тело функции без фигурных скобок.\nАргументы функции, которые могут использоваться внутри её тела, называются aValues. Примеры — смотрите на вкладке «Простые функции».
udf.newFunctionOnStepBody=Запишите тело функции без фигурных скобок.\nАргументы функции, которые могут использоваться внутри её тела, называются aValues. Пример — смотрите на вкладке «Встроенные функции».\nЛюбые значения, которые должны быть сохранены для использования в конечной [onFinal()] функции, могут быть сохранены в объекте this._store, который инициализируется пустым массивом.
udf.newFunctionOnFinalBody=Запишите тело функции без фигурных скобок.\nЭта функция не имеет аргументов. Примеры — смотрите на вкладке «Встроенные функции».\nДля вычислений в этой функции вы можете использовать объект this._store, после того как сохраните в нём значения в промежуточных [onStep()] функциях.
connectSql.forAllDb=Вы можете ввести, разделяя ';', несколько SQL-операторов, которые вы хотели бы выполнить сразу после подключения любой базы данных SQLite.\n\nЯ, например, люблю выполнять сразу после подключения любой базы данных «PRAGMA count_changes = 1». Если я введу этот оператор в следующее текстовое поле и сохраню его, то мне не надо напрягаться и запоминать, что надо вводить и выполнять эту директиву после каждого подключения к базе данных.\n\nЭти операторы сохраняются в параметре с именем extensions.sqlitemanager.onConnectSql.
connectSql.forThisDb=Вы можете ввести, разделяя ';', несколько SQL-операторов, которые вы хотели бы выполнить сразу после подключения именно этой базы данных SQLite.\n\nЭти SQL-операторы сохраняются в самой базе данных в таблице, используемой для хранения данных расширения.\n\nЭта функция может быть включена в меню «Инструменты» и становится доступной после перезагрузки этой вкладки.
