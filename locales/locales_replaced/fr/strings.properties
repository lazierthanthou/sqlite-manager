#

extensions.{SQLiteManager@mrinalkant.blogspot.com}.description=Gestionnaire de la base de données SQLite pour Mozilla Firefox.
dbDoesNotExist=Ce fichier n'existe pas : %1$S
lastDbDoesNotExist=Ce fichier n'existe plus :
promptLastDbTitle=Ouvrir avec la dernière base de données ?
promptLastDbAsk=Voulez-vous ouvrir la dernière base de données :
promptLastDbOpen=Ne plus demander. Ouvrir la dernière base de données
dropColumn=Supprimer la colonne
alterColumn=Alter Column
allowed=Autorisé
notAllowed=Interdit
noRecord=Aucune entrée sélectionnée
firstOpenADb=Vous devez d'abord ouvrir une base de données.
writeSomeSql=Veuillez entrer une commande SQL puis exécutez-la.
importData=Importer des données
noDbOrTable=Base de données et/ou table non sélectionnée.
noDb=Base de données non sélectionnée
onlyOneRecord=Sélectionner une entrée à éditer.
selectProfileDb=(Choisir le profil de la base de données)
selectDbInDefaultDir=(Select DB In Default Dir)
invalidProfileDb=Sélection invalide. Veuillez choisir un fichier à partir du menu déroulant.
extName=Gestionnaire SQLite
sqlite=SQLite
filesInProfileDbList=Nombre de fichiers dans la liste de bases de données du profil
dropDone=Suppression effectuée
noObjectToDelete=Échec de la suppression : il n'existe aucun objet de type
selectDb=Choisissez une base de donnée SQLite
ok=OK
notOk=Pas OK
sqliteDbFiles=Bases de données SQLite
copyFailed=La copie a échoué. Voulez-vous créer une nouvelle base de données ?
noOpenDb=Base de données ouverte introuvable
loadDataFailed=Échec du chargement des données.
rowsReturned=Nombre de lignes retournées
selectFolderForDb=Sélectionner un dossier pour sauvegarder la base de données
dbFileExists=Le fichier existe. Vous ouvrez une base de données existante
confirmClose=Voulez-vous vraiment fermer la base de données actuellement ouverte ?
confirmBackup=Do you want to backup this database file before opening it?
integrityResultPrefix=Vérification de l'intégrité de la base de données.\nRésultat
pragma.changed=PRAGMA %1$S: The value has changed to %2$S.
confirm.changeSchemaVersion=The schema-version is usually only manipulated internally by SQLite. It is incremented by SQLite whenever the database schema is modified (by creating or dropping a table or index). The schema version is used by SQLite each time a query is executed to ensure that the internal cache of the schema used when compiling the SQL query matches the schema of the database against which the compiled query is actually executed. Subverting this mechanism by using 'PRAGMA schema_version' to modify the schema-version is potentially dangerous and may lead to program crashes or database corruption. Use with caution!
dangerous.op=Dangerous Operation
q.proceed=Do you still want to proceed?
vacuum.title=Result of Compacting
vacuum.details=The database was compacted using VACUUM statement.\nBefore compacting:\n\tPage Count    = %1$S\n\tDatabase Size = %2$S bytes\nAfter compacting:\n\tPage Count    = %3$S\n\tDatabase Size = %4$S bytes
#

createMngr.index.title=Create Index on Table %1$S
createMngr.index.donotuse=Ne pas utiliser
createMngr.index.ascending=Croissant
createMngr.index.descending=Décroissant
createMngr.index.cannotBeNull=Name cannot be null
createMngr.index.noFieldsSelected=No fields selected
createMngr.index.confirm=Create Index %1$S
createMngr.dropColumn=Drop Column %1$S from %2$S
createMngr.alterColumn=Alter Column %1$S in table %2$S
createMngr.tbl.cannotBeNull=Table Name cannot be null
createMngr.tbl.cannotBeginSqlite=Table Name cannot begin with sqlite_
createMngr.invalidColname=Column Name cannot be one of rowid, _rowid_, oid
createMngr.autoincError.cols=AUTOINCREMENT on more than one column is an error.
createMngr.autoincError.PK=AUTOINCREMENT not allowed if primary key is over two or more columns.
createMngr.modifyView=Modify View
createMngr.view.cannotBeNull=Name cannot be null
createMngr.statement.cannotBeNull=Statement cannot be null
createMngr.trigger.cannotBeNull=Name cannot be null
createMngr.trigger.cannotBeEmpty=Trigger steps cannot be empty
createMngr.trigger.confirm=Create Trigger %1$S
#

eximTab.import.label=Import Wizard   
eximTab.export.label=Export Wizard   
eximTab.export.subtitle=Exporting the %1$S: 
eximLblObjectType=Name of the 
eximTab.export.label02=Export Wizard: Exporting the %1$S: 
exim.exportToFile=Export to file 
exim.chooseFileExport=Please choose a file to save the exported data to.
exim.exportNum=%1$S records exported to %2$S
exim.chooseFileImport=Select File to Import
exim.alertNull.title=SQLite Manager - Import Error
exim.alertNull.msg=Import Error: No file to import from!\nPlease select the file which contains the data you want to import.
exim.importNum.title=Import: 
exim.importNum.statements=%1$S statements executed.
exim.importNum.records=%1$S records imported.
exim.importFailed=Import Error: Import failed.
exim.importCancelled=Import cancelled.
exim.import.tablename=Enter the name of the table in which data will be imported:
exim.import.invalidTablename=Import Error: Please enter a valid table name.
exim.confirm.rows.title=SQLite Manager
exim.confirm.rows.msg=Are you sure you want to perform the following operation(s):\nImport Data: Rows = 
exim.import.failed=Failed to import %1$S lines.\nRow numbers: 
exim.confirm.sqlStats.title=SQLite Manager
exim.confirm.sqlStats.msg=Are you sure you want to perform the following operation(s):\nImport Data by executing SQL statements\nNumber of SQL statements: 
exim.confirm.irows.title=SQLite Manager
exim.confirm.irows.msg=Are you sure you want to perform the following operation(s):\nImport Data: Rows = 
exim.confirm.tabName.title=SQLite Manager
exim.confirm.tabName.msg=Are you sure you want to import the data to an existing table %1$S?\nClick OK to continue importing.
exim.confirm.createTable.title=SQLite Manager
exim.confirm.createTable.msg=A new table called %1$S will be created. Do you want to modify this table?\nClick OK to modify.
#

extManager.dropTableConfirm=Are you sure you want to drop the table %1$S?\nYou will lose all the data related to Query History, Saved queries, etc. in execute sql tab.\n\nClick on Cancel to disable the use of this table without deleting it from this database.
extManager.deleteQueries=Deleted all stored queries from table: 
extManager.qName.enter=Enter the name of the query to be saved
extManager.qName.exists=A query having the chosen name already exists.
#

globals.confirm.msg=Are you sure you want to perform the following operation(s):
globals.confirm.title=Confirm the operation
#

rowOp.insert.title=Add New Record
rowOp.insertSuccess.msg=Record inserted successfully. You can add another record now. Press Cancel to exit this dialog.
rowOp.insertFailure.msg=Failure in inserting record. You can add another record now. Press Cancel to exit this dialog.
rowOp.update.title=Edit Record
rowOp.updateSuccess.msg=Record updated successfully. Press Cancel to exit this dialog.
rowOp.updateFailure.msg=Failure in updating record. Press Cancel to exit this dialog.
rowOp.delete.title=Delete Record
rowOp.search.title=Search in table: 
rowOp.searchView.title=Search in view: 
rowOp.enterFieldValues=Enter Field Values
rowOp.saveBlob.fp.title=Save Blob to File
rowOp.addBlob.fp.title=Select Blob File
rowOp.addBlob.showBlobSize= (Size: %1$S)
rowOp.tooltip.expandInput=Expand the input area
rowOp.tooltip.collapseInput=Collapse the input area
rowOp.tooltip.addBlob=Add File as a Blob
rowOp.tooltip.saveBlob=Save Blob data as a file
rowOp.tooltip.deleteBlob=Delete the Blob data from this column
rowOp.viewName=View Name : 
rowOp.noChanges=No field has been changed. You can use Cancel button to cancel the operation
rowOp.confirmation=Are you sure you want to execute the following statement(s):
#

sqlite.size= (Size: %1$S)
sqlite.blobSize=BLOB (Size: %1$S)
sqlite.confirm.deleteRecords=Delete All Records
sqlite.confirm.renameTable=Rename table %1$S
sqlite.confirm.analyzeTable=Analyze Table
sqlite.confirm.addColumn=Add Column to Table %1$S
#

sqlm.selectQuery=Select a Query
sqlm.noForeignKey=no foreign key defined on this table
sqlm.fKeyNoTable=Failed: the referenced table %1$S does not exist
sqlm.fKeySelfReference=Failed: at least one foreign key references this table itself
sqlm.fKeyUnnamedColumn=Failed: the column %1$S references an unnamed column (could be due to implicit reference which is not handled)
sqlm.confirm.title=Confirm the operation
sqlm.confirm.msg=Do you want to create the triggers for the foreign keys?\n\n
sqlm.nothingToSave=Nothing to save.
sqlm.enterDatabaseName=Enter the database name (%1$S will be automatically appended to the name)
sqlm.enterDatabaseName.title=Enter the Database Name
sqlm.enterADSName=Enter ADS Name: 
sqlm.enterADSName.descr=Enter the name of ADS containing sqlite db
sqlm.alert.fileNotFound=File not found: 
sqlm.confirm.createTable=Create Table %1$S
sqlm.confirm.createObj=Create %1$S %2$S
sqlm.confirm.modifyView=Modify view  %1$S
sqlm.confirm.dangerousOp=This is a potentially dangerous operation. SQLite does not support statements that can alter a column in a table. Here, we attempt to reconstruct the new CREATE SQL statement by looking at the pragma table_info which does not contain complete information about the structure of the existing table.\n\n
sqlm.alterColumn.name=Please specify the new name of the column
#

sqlm.export.fp.title=Export to file 
sqlm.export.fp.descr=Please choose a file to save the exported data to.
sqlm.export.db=Database exported to %1$S
sqlm.export.dbstructure=Database Structure exported to %1$S
sqlm.export.tables=%1$S tables exported to %2$S
sqlm.renameTable=Rename Table %1$S
sqlm.renameTable.descr=Enter the new name of the table
sqlm.renameTable.confirm=Rename table %1$S
sqlm.renameObj=Rename %1$S %2$S
sqlm.renameObj.descr=Enter the new name of the %1$S
sqlm.renameObj.newSqlFailed=Failed to create sql statement
sqlm.renameObj.confirm=Rename %1$S %2$S
sqlm.copyTable.newSqlFailed=Failed to create sql statement for copying the table
sqlm.copyTable.confirm=Copy the table
sqlm.deleteRecs=Delete %1$S records from %2$S
sqlm.selectDefaultDir=Select Default Directory
sqlm.tooltip.profileDir=Profile Directory
sqlm.detachDb.alert=Cannot detach this item. This operation is valid on an attached database only.
sqlm.detachDb.confirm=Are you sure you want to detach the database %1$S?\nThe path of the attached db is: 
sqlm.detachDb.msgOk=Database %1$S detached.
sqlm.detachDb.msgFailed=Database %1$S failed to detach.
sqlm.attachDb=Attach Database %1$S
sqlm.attachDb.descr=Enter the database name
sqlm.attachDb.msgOk=Database %1$S attached as %2$S
sqlm.attachDb.msgFailed=Database %1$S failed to attach.
sqlm.backup.failed=Failed to create the backup file: %1$S\nException Message: %2$S
sqlm.tooltip.tempObj=Temporary Objects
sqlm.tooltip.tempDbObj=Temporary DB Objects
sqlm.tooltip.attachedDbs=--- Attached Databases ---
defaultval.title=No default value
defaultval.message=There is no default value associated with this column
udf.newFunctionArgLength=The number of arguments that the function will accept should be an integer.\n-1 means unlimited number of arguments.
udf.newFunctionBody=Write the function body without braces.\nThe argument to the function is "aValues" which can be used within the function body as in the example functions which you can see under the Simple Functions tab.
udf.newFunctionOnStepBody=Write the function body without braces.\nThe argument to the function is "aValues" which can be used within the function body as in the example functions which you can see under the Aggregate Functions tab.\nAny values you need to store for use in onFinal() can be stored in this._store which is initialized as an empty array
udf.newFunctionOnFinalBody=Write the function body without braces.\nThis function takes no arguments. See an example under the Aggregate Functions tab.\nYou can use this._store for computation in this function after you have stored values in it in the onStep() function.
connectSql.forAllDb=You can enter a number of SQL statements (separated by ;) which you would like to be executed immediately after a connection is made to any sqlite database.\n\nAs an example, I like to execute "PRAGMA foreign_keys = 1" immediately after connecting to any database. If I enter this pragma statement in the following textbox and save it, then I do not need to strain myself to remember this, type it and run it every time I connect to a database.\n\nThese statements are stored in a preference called "extensions.sqlitemanager.onConnectSql".
connectSql.forThisDb=You can enter a number of SQL statements (separated by ;) which you would like to be executed immediately after a connection is made to this sqlite database. This functionality is on a per-database basis.\n\nThese SQL statements are stored in this database itself in the table used to store extension data.\n\nThis functionality can be enabled from the Tools menu. After enabling this functionality, please Reload this tab to enable editing.
