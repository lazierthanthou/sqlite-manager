#

extensions.{SQLiteManager@mrinalkant.blogspot.com}.description=SQLite Database Manager para Mozilla Firefox.
dbDoesNotExist=No existe el archivo:%1$S
lastDbDoesNotExist=Ya no existe el archivo:%1$S
promptLastDbTitle=¿Abrir con la última base de datos?
promptLastDbAsk=Desea abrir la última base de datos usada:
promptLastDbOpen=No volver a preguntar. Abrir la última base de datos
dropColumn=Eliminar Columna
alterColumn=Modificar Columna
allowed=Permitido
notAllowed=No Permitido
noRecord=Sin Registro seleccionado
firstOpenADb=Primero debe abrir una base de datos
writeSomeSql=Por favor escriba alguna sentencia SQL antes de Ejecutarla.
importData=Importar Datos
noDbOrTable=Base de Datos y/o Tabla No Seleccionada
noDb=Base de Datos No Seleccionada
onlyOneRecord=Selecciona un y sólo un registro a editar.
selectProfileDb=(Seleccionar Perfil Base de Datos)
selectDbInDefaultDir=(Seleccionar DB en Carpeta por Defecto)
invalidProfileDb=Selección inválida. Por favor seleccione un archivo para el menú desplegable.
extName=SQLite Manager
sqlite=SQLite
filesInProfileDbList=Numero de archivos en la carpeta seleccionada
dropDone=DROP exitoso
noObjectToDelete=Fallo en el borrado, no existe el objeto del tipo
selectDb=Selecciona Base de Datos SQLite
ok=OK
notOk=No OK
sqliteDbFiles=Archivos SQLite DB
copyFailed=Fallo Copia. ¿Desea crear una nueva base de datos?
noOpenDb=No se ha encontrado base de datos abierta.
loadDataFailed=Fallo al cargar los datos.
rowsReturned=Número de Filas Devueltas:%1$S
selectFolderForDb=Seleccione Carpeta para Guardar el archivo DB
dbFileExists=Ya existe el archivo. Está abriendo una base de datos existente.
confirmClose=¿Seguro que desea cerrar la base de datos actual?
confirmBackup=¿Desea realizar una copia de seguridad de la base de datos antes de abrirla?
integrityResultPrefix=Comprobada Integridad de la base de datos.\nResultado.
pragma.changed=PRAGMA %1$S: El valor a cambiado a %2$S.
confirm.changeSchemaVersion=La versión del esquema es generalmente manipulada internamente por SQLite. Es incrementada por SQLite mientras el esquema de la pase de datos es modificado (creando o eliminando una tabla o indice). La versión del esquema es usada por SQLite cada vez que una consulta es ejecutada para asegurar que la caché interna del esquema usada al compilar las consultas SQL combatiendo el esquema de la base de datos cuya consulta compilada está ejecutándose. Invirtiendo este mecanismo mediante 'PRAGMA schema_version' para modificar la versión del esquema es potencialmente peligroso y puede llevar a cuelgues en el programa o la corrupción de la base de datos. ¡Usar con precaución!
dangerous.op=Operación Peligrosa
q.proceed=¿Desea continuar de todas formas?
vacuum.title=Resultado de la Compactación
vacuum.details=La base de datos fue compactada usando la sentencia VACUUM. \nAntes de compactar:\n\tRecuento de pagina= %1$S\n\tTamaño de la base de Datos = %2$S bytes\nDespués de compactar:\n\tRecuento de pagina = %3$S\n\tTamaño de la base de datos = %4$S bytes
#

createMngr.index.title=Crear Indice en Tabla %1$S
createMngr.index.donotuse=No usar
createMngr.index.ascending=Ascendiente
createMngr.index.descending=Descendiente
createMngr.index.cannotBeNull=El nombre no puede ser null
createMngr.index.noFieldsSelected=Sin campos seleccionados
createMngr.index.confirm=Crear Indice %1$S
createMngr.dropColumn=Eliminar Columna %1$S de %2$S
createMngr.alterColumn=Alterar Columna %1$S en la tabla %2$S
createMngr.tbl.cannotBeNull=El nombre de tabla no puede ser null
createMngr.tbl.cannotBeginSqlite=EL nombre de tabla ni puede empezar con sqlite_
createMngr.invalidColname=El nombre de columna no puede ser rowid, _rowid_, ó oid
createMngr.autoincError.cols=AUTOINCREMENT en más de una columna es un error.
createMngr.autoincError.PK=AUTOINCREMENT no permitido si la clave primaria está formada por dos o mas columnas.
createMngr.modifyView=Modificar vista
createMngr.view.cannotBeNull=El nombre no puede ser null
createMngr.statement.cannotBeNull=La sentencia no puede ser null
createMngr.trigger.cannotBeNull=El nombre no puede ser null
createMngr.trigger.cannotBeEmpty=Los pasos del trigger no pueden ser vacíos
createMngr.trigger.confirm=Crear Trigger %1$S
#

eximTab.import.label=Asistente de Importación
eximTab.export.label=Asistente de Exportación
eximTab.export.subtitle=Exportando %1$S:
eximLblObjectType=Nombre de el
eximTab.export.label02=Asistente de Exportación: Exportando %1$S:
exim.exportToFile=Exportar a archivo
exim.chooseFileExport=Por favor elija un archivo para exportar los datos.
exim.exportNum=%1$S registros exportados a %2$S
exim.chooseFileImport=Seleccione Archivo a Importar
exim.alertNull.title=SQLite Manager - Error de Importación
exim.alertNull.msg=Error de Importación: ¡Falta archivo desde el que importar!\nPor favor seleccione el archivo que contiene los datos que desea importar.
exim.importNum.title=Importar:
exim.importNum.statements=%1$S sentencias ejecutadas.
exim.importNum.records=%1$S registros importados.
exim.importFailed=Error de Importación: Importación fallida.
exim.importCancelled=Importación cancelada.
exim.import.tablename=Introducir el nombre de la tabla en los datos serán importados:
exim.import.invalidTablename=Error de Importación: Por favor introduzca un nombre de tabla válido.
exim.confirm.rows.title=SQLite Manager
exim.confirm.rows.msg=Está seguro de que desea realizar las operaciones siguientes:\nImportar Datos: filas =
exim.import.failed=Fallo al importar lineas %1$S.\n Número de filas:
exim.confirm.sqlStats.title=SQLite Manager
exim.confirm.sqlStats.msg=Está seguro de que desea realizar las las siguientes operaciones:\nImportar Datos mediante la ejecución de sentencias SQL\nNúmero de sentencias SQL:
exim.confirm.irows.title=SQLite Manager
exim.confirm.irows.msg=Está seguro de que desea realizar las las siguientes operaciones:\nImportar Datos: Filas =
exim.confirm.tabName.title=SQLite Manager
exim.confirm.tabName.msg=¿Está seguro de que desea importar los datos a una tabla existente %1$S?\n Haga clic en OK para continuar importando.
exim.confirm.createTable.title=SQLite Manager
exim.confirm.createTable.msg=Una nueva tabla llamada %1$S será creada- ¿Desea modificar esta tabla?\n Haga clic en OK para modificarla.
#

extManager.dropTableConfirm=¿Está seguro de que desea eliminar la tabla %1$S?\nPerderá todos los datos relacionados al Historial de Consultas en la pestaña ejecutar sql.
extManager.deleteQueries=Borrados todos las consultas de la tabla:
extManager.qName.enter=Introducir el nombre de la consulta a guardar.
extManager.qName.exists=Ya existe una consulta con el mismo nombre
#

globals.confirm.msg=Está seguro de que desea realizar las siguientes operaciones:
globals.confirm.title=Confirmar la operación.
#

rowOp.insert.title=Añadir Nuevo Registro
rowOp.insertSuccess.msg=Registro insertado correctamente. Puede añadir otro registro ahora. Pulse Cancelar para salir.
rowOp.insertFailure.msg=Fallo al insertar registro. Puede añadir otro registro ahora. Pulse Cancelar para salir.
rowOp.update.title=Editar Registro
rowOp.updateSuccess.msg=Registro actualizado correctamente. Pulse Cancelar para salir.
rowOp.updateFailure.msg=Fallo en la actualización de registros. Pulse Cancelar para salir.
rowOp.delete.title=Borrar Registro
rowOp.search.title=Buscar en la tabla:
rowOp.searchView.title=Buscar en vista:
rowOp.enterFieldValues=Introducir Valores del Campo
rowOp.saveBlob.fp.title=Guardar BLOB a Archivo
rowOp.addBlob.fp.title=Seleccionar archivo BLOB
rowOp.addBlob.showBlobSize=(Tamaño: %1$S)
rowOp.tooltip.expandInput=Expandir el área de entrada
rowOp.tooltip.collapseInput=Contraer el área de entrada
rowOp.tooltip.addBlob=Añadir Archivo como BLOB
rowOp.tooltip.saveBlob=Guardar datos BLOB como archivo
rowOp.tooltip.deleteBlob=Borrar datos BLOB de esta columna
rowOp.viewName=Nombre de vista:
rowOp.noChanges=Ningún campo a cambiado. Puede usar el botón Cancelar para cancelar la operación.
rowOp.confirmation=Está seguro de que desea ejecutar las siguientes sentencias:
#

sqlite.size=(Tamaño: %1$S)
sqlite.blobSize=BLOB (Tamaño: %1$S)
sqlite.confirm.deleteRecords=Borrar Todos los Registros
sqlite.confirm.renameTable=Renombrar tabla %1$S
sqlite.confirm.analyzeTable=Analizar Tabla
sqlite.confirm.addColumn=Añadir Columna a la Tabla %1$S
#

sqlm.selectQuery=Selecciona una consulta
sqlm.noForeignKey=No hay clave ajena definida en esta tabla
sqlm.fKeyNoTable=Fallida: la tabla referenciada %1$S no existe
sqlm.fKeySelfReference=Fallida: al menos una clave ajena referencia a esta misma tabla
sqlm.fKeyUnnamedColumn=Fallido: la columna %1$S referencia una columna sin nombre (puede ser debido a una referencia implícita que no está controlada)
sqlm.confirm.title=Confirmar la operación
sqlm.confirm.msg=¿Desea crear los triggers para las claves ajenas?\n\n
sqlm.nothingToSave=Nada que guardar.
sqlm.enterDatabaseName=Introduzca el nombre de la base de datos (%1$S será automáticamente añadido al nombre)
sqlm.enterDatabaseName.title=Introducir nombre de la Base de Datos
sqlm.enterADSName=Introducir Nombre ADS:
sqlm.enterADSName.descr=Introduzca el nombre de ADS contenedor de la base de datos sqlite
sqlm.alert.fileNotFound=Archivo no encontrado:
sqlm.confirm.createTable=Crear Tabla %1$S
sqlm.confirm.createObj=Crear %1$S %2$S
sqlm.confirm.modifyView=Modificar vista %1$S
sqlm.confirm.dangerousOp=Esta es una operación potencialmente peligrosa. SQLite no soporta sentencias que puedan alterar una columna en una tabla. Aquí, intentaremos reconstruir la nueva sentencia CREATE SQL buscando en el pragma table_info que no contiene información completa sobre a estructura de la tabla existente.\n\n
sqlm.alterColumn.name=Por favor especifique el nuevo nombre de la columna
#

sqlm.export.fp.title=Exportar a archivo
sqlm.export.fp.descr=Por favor elija un archivo para guardar los datos exportados.
sqlm.export.db=Base de Datos exportada a %1$S
sqlm.export.dbstructure=Estructura de la Base de Datos exportada a %1$S
sqlm.export.tables=%1$S tablas exportadas a %2$S
sqlm.renameTable=Renombrar Tabla %1$S
sqlm.renameTable.descr=Introducir el nuevo nombre de la tabla
sqlm.renameTable.confirm=Renombrar tabla %1$S
sqlm.renameObj=Renombrar %1$S %2$S
sqlm.renameObj.descr=Introducir el nuevo nombre para %1$S
sqlm.renameObj.newSqlFailed=Fallo al crear sentencia sql
sqlm.renameObj.confirm=Renombrar %1$S %2$S
sqlm.copyTable.newSqlFailed=Fallo al crear sentencia sql para copiar la tabla
sqlm.copyTable.confirm=Copiar la tabla
sqlm.deleteRecs=Borrar %1$S registros de %2$S
sqlm.selectDefaultDir=Seleccionar Directorio por Defecto
sqlm.tooltip.profileDir=Carpeta de Perfil
sqlm.detachDb.alert=No se puede desconectar este elemento. Esta operación es válida sólo en una base de datos conectada.
sqlm.detachDb.confirm=¿Está seguro de que quiere desconectar la base de datos %1$S?\nLa ruta de la base de datos conectada es:
sqlm.detachDb.msgOk=Base de datos %1$S desconectada.
sqlm.detachDb.msgFailed=Fallo al desconectar la base de datos %1$S.
sqlm.attachDb=Adjuntar Base de Datos %1$S
sqlm.attachDb.descr=Introducir el nombre de la base de datos.
sqlm.attachDb.msgOk=Base de datos %1$S adjuntada como %2$S
sqlm.attachDb.msgFailed=Fallo al adjuntar base de datos %1$S
sqlm.backup.failed=Fallo al crear la copia de seguridad:%1$S\nMensaje de Excepción: %2$S
sqlm.tooltip.tempObj=Objetos Temporales
sqlm.tooltip.tempDbObj=Objetos Temporales DB
sqlm.tooltip.attachedDbs=---Bases de Datos Adjuntas---
defaultval.title=Sin valor por defecto
defaultval.message=No hay valor por defecto asociado a esta columna
udf.newFunctionArgLength=El numero de argumentos que la función aceptará debe ser un entero.\n-1 significa número ilimitado de argumentos.
udf.newFunctionBody=Escriba el cuerpo de la función sin corchetes.\nEl argumento de la función es "aValues" que puede ser usado en el cuerpo de la función como se puede ver en las funciones de ejemplo bajo la pestaña Funciones Simples.
udf.newFunctionOnStepBody=Escriba el cuerpo de la función sin corchetes.\nEl argumento de la función es "aValues" que puede ser usado en el cuerpo de la función como se puede ver en las funciones de ejemplo bajo la pestaña Funciones Agregadas.\nCualquier valor que necesite guardar para usar en onFinal() puedes ser guardada en este._store el cual es inicializado como un array vacío.
udf.newFunctionOnFinalBody=Escriba la función sin corchetes.\nEsta función no tiene argumentos. Vea un ejemplo bajo la pestaña Funciones Agregadas.\nPuede usar este._store para computación en esta función después de tener valores guardados en él en la función onStep().
connectSql.forAllDb=Puede introducir un número de sentencias SQL (separadas por ;) las cuales desea que sean ejecutadas inmediatamente después de que se realice la conexión a cualquier base de datos sqlite.\n\nComo ejemplo, me gustaría ejecutar "PRAGMA foreign_keys = 1" inmediatamente después de la conexión a cualquier base de datos. Si he introducido esta sentencia pragma en el siguiente cuadro de texto y la guardo, después no necesitaré esforzarme en recordarla, escribirla y ejecutarla cada vez que me conecte con la base de datos.\n\nEstas sentencias están guardadas en una opción llamada "extensions.sqlitemanager.onConnectSql".
connectSql.forThisDb=Puede introducir un número de sentencias SQL (separadas por ;) las cuales desea que sean ejecutadas inmediatamente después de que se realice la conexión a esta base de datos sqlite. Esta funcionalidad esta en una Per-Database Basis.\n\nEstas sentencias SQL están guardadas en la misma base de datos en la tabla usada para guardar los datos de extensión.\n\n Esta funcionalidad puede ser habilitada desde el menu de Herramientas. Tras activar esta funcionalidad, por favor Actualice esta pestaña para permitir la edición.
